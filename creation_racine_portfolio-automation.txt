# Créer les sous-dossiers
$folders = @(
    "scripts",
    "newsletters",
    ".github\workflows"
)

foreach ($folder in $folders) {
    $path = Join-Path -Path "." -ChildPath $folder
    if (-not (Test-Path $path)) {
        New-Item -Path $path -ItemType Directory -Force
        Write-Host "Dossier $path créé"
    }
}

# Créer le fichier newsletter_generator.py
$newsletterGeneratorPath = Join-Path -Path "." -ChildPath "scripts\newsletter_generator.py"
$newsletterGeneratorContent = @'
import os
import yaml
import markdown
import re
from datetime import datetime, timedelta
from pathlib import Path
import logging

# Configuration du logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger('newsletter_generator')

def extract_metadata_and_content(md_file_path):
    """
    Extrait les métadonnées et le contenu d'un fichier Markdown.
    """
    try:
        with open(md_file_path, 'r', encoding='utf-8') as file:
            content = file.read()

        # Vérifier la présence du format frontmatter YAML
        if content.startswith('---'):
            # Trouver les délimiteurs du frontmatter
            parts = content.split('---', 2)
            if len(parts) >= 3:
                # Extraire et parser les métadonnées
                metadata_yaml = parts[1].strip()
                try:
                    metadata = yaml.safe_load(metadata_yaml)
                    main_content = parts[2].strip()
                    return metadata, main_content
                except yaml.YAMLError as e:
                    logger.error(f"Erreur lors du parsing YAML dans {md_file_path}: {e}")
                    return {}, content
            else:
                logger.warning(f"Format de frontmatter incorrect dans {md_file_path}")
                return {}, content
        else:
            logger.warning(f"Pas de frontmatter trouvé dans {md_file_path}")
            return {}, content
    except Exception as e:
        logger.error(f"Erreur lors de la lecture du fichier {md_file_path}: {e}")
        return {}, ""

def get_recent_md_files(docs_directory, max_count=6, days_ago=7):
    """
    Récupère les fichiers Markdown les plus récents du répertoire docs.
    """
    try:
        if not os.path.exists(docs_directory):
            logger.error(f"Le répertoire {docs_directory} n'existe pas")
            return []

        now = datetime.now()
        cutoff_date = now - timedelta(days=days_ago)
        
        md_files = []
        for filename in os.listdir(docs_directory):
            if filename.endswith('.md'):
                file_path = os.path.join(docs_directory, filename)
                mod_time = datetime.fromtimestamp(os.path.getmtime(file_path))
                
                # Vérifier si le fichier a été modifié dans les X derniers jours
                if mod_time >= cutoff_date:
                    md_files.append({
                        'path': file_path,
                        'modified_at': mod_time,
                        'filename': filename
                    })
        
        # Trier par date de modification décroissante
        sorted_files = sorted(md_files, key=lambda x: x['modified_at'], reverse=True)
        
        # Limiter au nombre maximum spécifié
        return sorted_files[:max_count]
    except Exception as e:
        logger.error(f"Erreur lors de la récupération des fichiers récents: {e}")
        return []

def generate_newsletter_content(md_files):
    """
    Génère le contenu de la newsletter à partir des fichiers Markdown.
    """
    if not md_files:
        logger.warning("Aucun fichier Markdown récent trouvé")
        return "Aucun contenu récent disponible pour cette newsletter."

    newsletter_date = datetime.now().strftime("%d/%m/%Y")
    
    newsletter_content = f"""# Newsletter Portfolio - {newsletter_date}

Découvrez mes derniers projets et réalisations !

"""
    
    for file_info in md_files:
        metadata, content = extract_metadata_and_content(file_info['path'])
        
        title = metadata.get('title', os.path.splitext(file_info['filename'])[0])
        description = metadata.get('description', '')
        tags = metadata.get('tags', [])
        url = metadata.get('url', '')
        
        # Limiter le contenu pour l'aperçu
        summary = summarize_content(content, max_words=50)
        
        # Créer une section pour ce projet
        newsletter_content += f"""## {title}

{description}

{summary}

"""
        
        # Ajouter les tags s'ils existent
        if tags:
            tags_str = ', '.join([f"#{tag}" for tag in tags])
            newsletter_content += f"**Tags**: {tags_str}\n\n"
        
        # Ajouter un lien si disponible
        if url:
            newsletter_content += f"[En savoir plus]({url})\n\n"
        
        newsletter_content += "---\n\n"
    
    # Ajouter une signature
    newsletter_content += """
## Restons connectés !

N'hésitez pas à me contacter pour discuter de projets ou simplement échanger sur nos domaines d'intérêt communs.

- [Portfolio](https://votre-portfolio.com)
- [LinkedIn](https://www.linkedin.com/in/alexiafontaine)
"""
    
    return newsletter_content

def summarize_content(content, max_words=50):
    """
    Crée un résumé du contenu en limitant le nombre de mots.
    """
    # Convertir le Markdown en texte brut (approche simplifiée)
    # Supprimer les liens Markdown
    text = re.sub(r'\[([^\]]+)\]\([^)]+\)', r'\1', content)
    # Supprimer les balises Markdown basiques
    text = re.sub(r'[*#_~`]', '', text)
    
    words = text.split()
    if len(words) <= max_words:
        return text
    
    return ' '.join(words[:max_words]) + "..."

def save_newsletter(content, output_directory):
    """
    Sauvegarde la newsletter dans un fichier avec un nom horodaté.
    """
    try:
        # Créer le répertoire de sortie s'il n'existe pas
        Path(output_directory).mkdir(parents=True, exist_ok=True)
        
        # Générer un nom de fichier avec la date
        timestamp = datetime.now().strftime("%Y%m%d")
        filename = f"newsletter_{timestamp}.md"
        
        file_path = os.path.join(output_directory, filename)
        
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(content)
        
        logger.info(f"Newsletter sauvegardée: {file_path}")
        return file_path
    except Exception as e:
        logger.error(f"Erreur lors de la sauvegarde de la newsletter: {e}")
        return None

def convert_to_html(markdown_content):
    """
    Convertit le contenu Markdown en HTML pour publication sur LinkedIn.
    """
    try:
        html_content = markdown.markdown(markdown_content)
        return html_content
    except Exception as e:
        logger.error(f"Erreur lors de la conversion en HTML: {e}")
        return markdown_content

def main():
    # Chemins des répertoires (à ajuster selon votre configuration)
    portfolio_directory = os.environ.get('PORTFOLIO_DIR', '../portfolio')
    docs_directory = os.path.join(portfolio_directory, 'docs')
    output_directory = os.environ.get('OUTPUT_DIR', '../portfolio-automation/newsletters')
    
    logger.info(f"Recherche de fichiers Markdown récents dans {docs_directory}")
    
    # Récupérer les fichiers Markdown récents
    recent_files = get_recent_md_files(docs_directory)
    
    if recent_files:
        logger.info(f"Nombre de fichiers récents trouvés: {len(recent_files)}")
        for file in recent_files:
            logger.info(f"  - {file['filename']} (modifié le {file['modified_at']})")
    else:
        logger.warning("Aucun fichier récent trouvé")
    
    # Générer le contenu de la newsletter
    newsletter_content = generate_newsletter_content(recent_files)
    
    # Sauvegarder la newsletter au format Markdown
    md_path = save_newsletter(newsletter_content, output_directory)
    
    if md_path:
        # Également sauvegarder une version HTML pour LinkedIn
        html_content = convert_to_html(newsletter_content)
        html_path = md_path.replace('.md', '.html')
        
        try:
            with open(html_path, 'w', encoding='utf-8') as f:
                f.write(html_content)
            logger.info(f"Version HTML sauvegardée: {html_path}")
        except Exception as e:
            logger.error(f"Erreur lors de la sauvegarde de la version HTML: {e}")
    
    logger.info("Génération de la newsletter terminée")

if __name__ == "__main__":
    main()
'@

Set-Content -Path $newsletterGeneratorPath -Value $newsletterGeneratorContent
Write-Host "Fichier $newsletterGeneratorPath créé"

# Créer le fichier de workflow GitHub Actions
$workflowPath = Join-Path -Path "." -ChildPath ".github\workflows\generate_newsletter.yml"
$workflowContent = @'
name: Génération de Newsletter LinkedIn

on:
  schedule:
    # Exécution tous les lundis à 9h00 UTC
    - cron: '0 9 * * 1'
  workflow_dispatch:  # Permet le déclenchement manuel

jobs:
  generate-newsletter:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout du dépôt portfolio-automation
      uses: actions/checkout@v3
      with:
        path: portfolio-automation
    
    - name: Checkout du dépôt portfolio
      uses: actions/checkout@v3
      with:
        repository: votre-username/portfolio
        path: portfolio
        token: ${{ secrets.GH_PAT }}
    
    - name: Configuration de Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
    
    - name: Installation des dépendances
      run: |
        python -m pip install --upgrade pip
        pip install PyYAML markdown
    
    - name: Génération de la newsletter
      run: |
        cd portfolio-automation
        python scripts/newsletter_generator.py
      env:
        PORTFOLIO_DIR: ${{ github.workspace }}/portfolio
        OUTPUT_DIR: ${{ github.workspace }}/portfolio-automation/newsletters
    
    - name: Commit des changements
      run: |
        cd portfolio-automation
        git config user.name "GitHub Actions Bot"
        git config user.email "actions@github.com"
        git add newsletters/
        git diff --staged --quiet || git commit -m "Génération de la newsletter hebdomadaire"
        git push
'@

Set-Content -Path $workflowPath -Value $workflowContent
Write-Host "Fichier $workflowPath créé"

# Créer un README de base
$readmePath = Join-Path -Path "." -ChildPath "README.md"
$readmeContent = @'
# Portfolio Automation

Ce dépôt contient des scripts et workflows pour automatiser la création et la publication de contenus à partir de votre dépôt portfolio.

## Fonctionnalités

1. **Génération de Newsletter** : Crée automatiquement une newsletter hebdomadaire à partir des fichiers Markdown les plus récents de votre portfolio

## Comment ça marche

Le système génère chaque lundi une newsletter contenant jusqu'à 6 de vos contenus les plus récents (créés ou modifiés au cours des 7 derniers jours).

## Configuration nécessaire

1. Créez un token d'accès personnel GitHub avec les droits `repo`
2. Ajoutez-le comme secret dans le dépôt sous le nom `GH_PAT`
3. Modifiez le fichier workflow pour utiliser votre nom d'utilisateur GitHub

## Structure du dépôt

portfolio-automation/
├── .github/                    <-- Dossier caché avec un point au début
│   └── workflows/              <-- Sous-dossier obligatoire 
│       └── generate_newsletter.yml  <-- Fichier de workflow ici
├── scripts/                    <-- Vos scripts Python ici
│   └── newsletter_generator.py
├── newsletters/                <-- Résultats générés
└── README.md